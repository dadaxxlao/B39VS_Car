# å°è½¦çº¢å¤–å¯»è·¯ç®—æ³•è®¾è®¡ä¸è·¯å£è¯†åˆ«é€»è¾‘

### ğŸ§‘â€ğŸ’» User

å®é™…ä¸Šï¼Œæˆ‘ä»¬åœ¨å³æ—‹Tå­—å½¢è·¯å£å’Œå·¦æ—‹Tå­—è·¯å£çš„æƒ…å†µä¸‹ï¼Œä¼šéœ€è¦è¿›è¡Œç›´è¡Œæ“ä½œï¼Œéœ€è¦æ ¹æ®æ›´ç»†åŒ–çš„çŠ¶æ€æœºè¿›è¡Œå®ç°ã€‚å®é™…ä¸Šæˆ‘ä»¬å…±æœ‰ä¸‰ä¸ªä¸åŒçš„å¯»è·¯çŠ¶æ€ï¼Œç§°ä¸ºOBJECT_FIND, OBJECT_LOCATE, RETURN_BASEï¼Œä¸åŒçš„å¯»è·¯çŠ¶æ€åœ¨é¢å¯¹ä¸åŒè·¯å£æ—¶ä¼šéœ€è¦ä¸åŒçš„é€‰è·¯ç­–ç•¥ã€‚éœ€è¦è¿›ä¸€æ­¥ç»†åŒ–ã€‚

åˆå§‹çŠ¶æ€ä¸ºINITIALIZEDï¼Œæˆ‘ä»¬è¿›è¡Œæ‰€æœ‰æ¨¡å—çš„åˆå§‹åŒ–ï¼Œå¹¶æµ‹è¯•è¾“å…¥æ•°æ®æ˜¯å¦æ­£ç¡®ã€‚åœ¨æ¥æ”¶åˆ°ä¸Šä½æœºçš„ä¿¡å·åï¼Œè¿›å…¥OBJECT_FINDçŠ¶æ€ã€‚

åˆå§‹åŒ–ä¸€ä¸ªè®¡æ•°å™¨(Counter==0)
åœ¨OBJECT_FINDçŠ¶æ€ï¼šå¾ªè¿¹çŠ¶æ€ç›´è¡Œå¼€å§‹ï¼Œé‡åˆ°è·¯å£åˆ™è¿›è¡Œåˆ¤æ–­å¹¶è¿›å…¥å¯¹åº”æ“ä½œï¼Œé‡åˆ°å³Tå­—å½¢è·¯å£ç›´èµ°ç„¶åå›åˆ°OBJECT_FINDçŠ¶æ€ï¼Œé‡åˆ°å³è½¬è·¯å£å³è½¬ç„¶åå›åˆ°OBJECT_FINDçŠ¶æ€ï¼Œé‡åˆ°Tå­—å½¢è·¯å£å·¦è½¬ç„¶åå›åˆ°OBJECT_FINDçŠ¶æ€ï¼Œé‡åˆ°å·¦è½¬è·¯å£æˆ–å·¦Tå­—å½¢è·¯å£å·¦è½¬å¹¶è®¡æ•°å™¨åŠ 1ï¼Œç„¶åè¿›å…¥ULTRASONICâ€”â€”DETECTçŠ¶æ€ã€‚

åœ¨ULTRASONIC_DETECTçŠ¶æ€ï¼šè¿›è¡Œè¶…å£°æ³¢æ£€æµ‹ï¼ˆè¶…å£°æ³¢æ£€æµ‹ç»“æœä¸¤ç§æƒ…å†µï¼‰ï¼Œç¬¬ä¸€ç§æƒ…å†µå¦‚æœæ£€æµ‹åˆ°ç‰©å—åˆ™è¿›å…¥å¾ªè¿¹ç›´è¡Œå¹¶åœ¨ç‰©å—å‰åœä¸‹ï¼Œç„¶åè¿›å…¥OBJECT_GRABçŠ¶æ€ï¼Œç„¶åæ‰å¤´ï¼Œè¿™æ—¶å¦‚æœè®¡æ•°å™¨å°äºç­‰äº2ï¼Œåˆ™å›åˆ°OBJECT_FINDçŠ¶æ€ï¼Œè®¡æ•°å™¨ç­‰äº3æ—¶åˆ™è¿›å…¥OBJECT_LOCATEçŠ¶æ€ï¼›ç¬¬äºŒç§æƒ…å†µå¦‚æœæ²¡æœ‰æ£€æµ‹åˆ°ç‰©å—ï¼Œåˆ™æ‰å¤´ï¼Œè¿™æ—¶å¦‚æœè®¡æ•°å™¨å°äºç­‰äº2ï¼Œåˆ™å›åˆ°OBJECT_FINDçŠ¶æ€ï¼Œè®¡æ•°å™¨ç­‰äº3æ—¶åˆ™è¿›å…¥OBJECT_LOCATEçŠ¶æ€ï¼›

OBJECT_GRABçŠ¶æ€ï¼šæ ¹æ®è¶…å£°æ³¢è·ç¦»æ•°æ®ï¼Œæˆ‘ä»¬è¿›è¡Œå°è½¦å‰è¿›åé€€çš„è·ç¦»è°ƒæ•´ï¼Œç›´åˆ°åˆ°è¾¾æœºæ¢°è‡‚é•¿åº¦ï¼Œè°ƒç”¨æœºæ¢°è‡‚æ§åˆ¶å‡½æ•°ï¼Œè¿›è¡ŒæŠ“å–ã€‚éšåè¿›è¡Œé¢œè‰²è¯†åˆ«ï¼Œå¾—åˆ°é¢œè‰²ä»£å·ã€‚

åˆå§‹åŒ–ä¸€ä¸ªè®¡æ•°å™¨(Counter==0)
åœ¨OBJECT_LOCATEçŠ¶æ€ï¼šå¾ªè¿¹ç›´è¡Œå¼€å§‹ï¼Œé‡åˆ°è·¯å£åˆ™è¿›è¡Œåˆ¤æ–­å¹¶è¿›å…¥å¯¹åº”æ“ä½œï¼Œé‡åˆ°å³è½¬è·¯å£å³è½¬ç„¶åå›åˆ°å¾ªè¿¹çŠ¶æ€ï¼Œé‡åˆ°å³Tå­—å½¢è·¯å£ç›´è¡Œç„¶åå›åˆ°å¾ªè¿¹çŠ¶æ€ï¼Œé‡åˆ°å·¦è½¬è·¯å£å·¦è½¬ç„¶åå›åˆ°å¾ªè¿¹çŠ¶æ€ï¼Œé‡åˆ°å·¦Tå­—å½¢è·¯å£å·¦è½¬ç„¶åå›åˆ°COUNT_INTERSECTIONçŠ¶æ€ã€‚


åœ¨COUNT_INTERSECTIONçŠ¶æ€ï¼šå¾ªè¿¹ç›´è¡Œå¼€å§‹ï¼Œé‡åˆ°å³Tå­—å½¢è·¯å£è¿›è¡Œåˆ¤æ–­ï¼Œå¦‚æœè®¡æ•°å™¨==é¢œè‰²ä»£å·ï¼Œåˆ™å³è½¬ç„¶åè¿›å…¥OBJECT_PLACINGçŠ¶æ€ï¼›å¦‚æœè®¡æ•°å™¨<=é¢œè‰²ä»£å·ï¼Œåˆ™è®¡æ•°å™¨åŠ 1å¹¶ç›´è¡Œç„¶åå›åˆ°COUNT_INTERSECTIONçŠ¶æ€ï¼›

åœ¨OBJECT_PLACINGçŠ¶æ€ï¼šæ ¹æ®è¶…å£°æ³¢è·ç¦»æ•°æ®ï¼Œæˆ‘ä»¬è¿›è¡Œå°è½¦å‰è¿›åé€€çš„è·ç¦»è°ƒæ•´ï¼Œç›´åˆ°åˆ°è¾¾æœºæ¢°è‡‚é•¿åº¦ï¼Œè°ƒç”¨æœºæ¢°è‡‚æ§åˆ¶å‡½æ•°ï¼Œè¿›è¡Œæ”¾ç½®ï¼Œæ”¾ç½®å®Œæˆåæ‰å¤´ï¼Œè¿›å…¥RETURN_BASEçŠ¶æ€ã€‚

åœ¨RETURN_BASEçŠ¶æ€ï¼šå¾ªè¿¹ç›´è¡Œå¼€å§‹ï¼Œé‡åˆ°Tå­—è·¯å£æˆ–å·¦è½¬è·¯å£è¿›è¡Œä¸€æ¬¡å·¦è½¬ï¼Œéšåå¾ªè¿¹ç›´è¡Œï¼Œå†æ¬¡é‡åˆ°Tå­—å½¢è·¯å£å·¦è½¬ï¼Œéšåå¾ªè¿¹ç›´è¡Œï¼Œå½“å†æ¬¡è§¦å‘è·¯å£åˆ¤æ–­åˆ™è¯´æ˜åˆ°è¾¾åŸºåœ°è¾¹ç¼˜ï¼Œç»§ç»­ç›´è¡Œä¸€ä¸ªè®¾å®šæ—¶é•¿ï¼Œæœ€åè¿›å…¥ENDçŠ¶æ€ã€‚


---

### ğŸ¤– Assistant



åŸºäºæ‚¨çš„éœ€æ±‚ï¼Œæˆ‘é‡æ–°è®¾è®¡äº†ä¸€ä¸ªåˆ†å±‚çŠ¶æ€æœºæ¶æ„ï¼Œå°†**è·¯å¾„å†³ç­–é€»è¾‘**ä¸**ä»»åŠ¡çŠ¶æ€**æ·±åº¦ç»‘å®šï¼Œå¹¶é’ˆå¯¹ä¸åŒçŠ¶æ€ä¸‹çš„è·¯å£ç±»å‹å®šä¹‰å·®å¼‚åŒ–ç­–ç•¥ã€‚ä»¥ä¸‹æ˜¯è¯¦ç»†çš„ç³»ç»ŸåŒ–å®ç°æ–¹æ¡ˆï¼š

---

### **ä¸€ã€å…¨å±€çŠ¶æ€æœºå®šä¹‰**
```arduino
enum SystemState {
  INITIALIZED,     // åˆå§‹åŒ–çŠ¶æ€
  OBJECT_FIND,     // å¯»æ‰¾ç‰©å—
  OBJECT_GRAB,     // æŠ“å–ç‰©å—
  OBJECT_LOCATE,   // å®šä½æ”¾ç½®åŒºåŸŸ
  OBJECT_PLACING,  // æ”¾ç½®ç‰©å—
  RETURN_BASE,     // è¿”å›åŸºåœ°
  END              // ä»»åŠ¡ç»“æŸ
};

// å½“å‰ç³»ç»ŸçŠ¶æ€ï¼ˆéœ€å…¨å±€å˜é‡ï¼‰
SystemState currentState = INITIALIZED;
```

---

### **äºŒã€å­çŠ¶æ€ä¸è¾…åŠ©å˜é‡**
#### **1. OBJECT_LOCATEå­çŠ¶æ€**
```arduino
enum LocateSubState {
  TURN_AROUND,      // æ‰å¤´
  COUNT_JUNCTIONS,  // ç»Ÿè®¡ç»è¿‡çš„è·¯å£
  SELECT_TARGET      // é€‰æ‹©ç›®æ ‡è·¯å£
};

LocateSubState locateState = TURN_AROUND;
int junctionCounter = 0;   // è·¯å£è®¡æ•°å™¨
Color detectedColor;       // å­˜å‚¨é¢œè‰²æ•°æ®ï¼ˆéœ€ä¸é¢œè‰²ä¼ æ„Ÿå™¨è”åŠ¨ï¼‰
```

#### **2. è·¯å£ç±»å‹å®šä¹‰**
```arduino
enum JunctionType {
  NO_JUNCTION,
  T_LEFT,     // å·¦æ—‹Tå­—
  T_RIGHT,    // å³æ—‹Tå­—
  T_FORWARD   // æ­£Tå­—ï¼ˆå€’Tï¼‰
};
```

---

### **ä¸‰ã€æ ¸å¿ƒçŠ¶æ€è½¬ç§»é€»è¾‘**

#### **1. INITIALIZEDçŠ¶æ€**
```arduino
void handleInitialized() {
  // åˆå§‹åŒ–ä¼ æ„Ÿå™¨/ç”µæœº/é€šä¿¡
  initSensors();
  calibrateMotors();
  
  // ç­‰å¾…ä¸Šä½æœºä¿¡å·ï¼ˆä¼ªä»£ç ï¼‰
  if (receiveStartSignal()) {
    currentState = OBJECT_FIND;
  }
}
```

---

#### **2. OBJECT_FINDçŠ¶æ€ï¼ˆå·¦è½¬ä¼˜å…ˆç­–ç•¥ï¼‰**
```arduino
void handleObjectFind() {
  JunctionType junction = detectJunction();
  
  switch (junction) {
    case T_LEFT:     // å·¦Tå­—è·¯å£
      stop();
      turnLeft();
      checkObjectWithUltrasonic();  // è°ƒç”¨è¶…å£°æ³¢æ£€æµ‹ç‰©å—
      break;
      
    case T_RIGHT:    // å³Tå­—è·¯å£
      moveStraight(); // ç›´è¡Œï¼ˆä¸è½¬å‘ï¼‰
      break;
      
    case T_FORWARD:  // æ­£Tå­—ï¼ˆå€’Tï¼‰
      turnLeft();     // ä¼˜å…ˆå·¦è½¬
      break;
      
    default:
      followLine();   // æ­£å¸¸å·¡çº¿
  }
  
  // ç‰©å—å­˜åœ¨æ£€æµ‹é€»è¾‘
  if (objectDetected()) {
    currentState = OBJECT_GRAB;
  }
}

// è¶…å£°æ³¢æ£€æµ‹ç‰©å—å­˜åœ¨æ€§
void checkObjectWithUltrasonic() {
  if (readUltrasonic() > NO_OBJECT_DISTANCE) {
    uTurn();          // æ‰å¤´å¹¶é‡æ–°å¯»çº¿
  }
}
```

---

#### **3. OBJECT_GRABçŠ¶æ€ï¼ˆç²¾ç¡®è·ç¦»è°ƒæ•´ï¼‰**
```arduino
void handleObjectGrab() {
  // PIDæ§åˆ¶å°è½¦é è¿‘ç‰©å—
  float distance = readUltrasonic();
  adjustPosition(distance);  // é€šè¿‡PWMå¾®è°ƒä½ç½®
  
  if (distance <= GRAB_RANGE) {
    activateArm();           // è§¦å‘æœºæ¢°è‡‚æŠ“å–
    detectedColor = readColorSensor(); // è·å–é¢œè‰²æ•°æ®
    currentState = OBJECT_LOCATE;
    locateState = TURN_AROUND; // åˆå§‹åŒ–å­çŠ¶æ€
  }
}
```

---

#### **4. OBJECT_LOCATEçŠ¶æ€ï¼ˆé¢œè‰²å¯¼å‘è·¯å¾„ï¼‰**
```arduino
void handleObjectLocate() {
  switch (locateState) {
    case TURN_AROUND:
      uTurn();  // å®Œæˆæ‰å¤´
      locateState = COUNT_JUNCTIONS;
      junctionCounter = 0;
      break;
      
    case COUNT_JUNCTIONS:
      JunctionType junction = detectJunction();
      if (junction != NO_JUNCTION) {
        junctionCounter++;
        
        // è·¯å¾„å†³ç­–è§„åˆ™ï¼š
        if (junctionCounter == 1) {
          turnRight();    // ç¬¬ä¸€ä¸ªæ­£Tå­—å³è½¬
        } else if (junctionCounter == 2 || junctionCounter == 3) {
          turnLeft();     // ç¬¬äºŒã€ä¸‰ä¸ªå·¦Tå·¦è½¬
        } else {
          // æ ¹æ®é¢œè‰²é€‰æ‹©ç›®æ ‡è·¯å£
          if (shouldSelectTarget(junction)) {
            locateState = SELECT_TARGET;
          }
        }
      }
      followLine();
      break;
      
    case SELECT_TARGET:
      // æ ¹æ®é¢œè‰²ä»£ç é€‰æ‹©å³è½¬è·¯å£
      int targetJunction = (detectedColor == RED) ? 1 : 
                          (detectedColor == BLACK) ? 2 : 3;
      
      if (junctionCounter == targetJunction) {
        turnRight();
        currentState = OBJECT_PLACING;
      }
      break;
  }
}

// åˆ¤æ–­æ˜¯å¦åˆ°è¾¾é¢œè‰²æŒ‡å®šè·¯å£
bool shouldSelectTarget(JunctionType junction) {
  return (junction == T_RIGHT) && 
         (junctionCounter >= getColorThreshold(detectedColor));
}
```

---

#### **5. RETURN_BASEçŠ¶æ€ï¼ˆé€†å‘è·¯å¾„è®°å¿†ï¼‰**
```arduino
void handleReturnBase() {
  uTurn();  // åˆå§‹æ‰å¤´
  
  JunctionType junction = detectJunction();
  if (junction == T_LEFT) {
    turnLeft();  // ç¬¬ä¸€ä¸ªè·¯å£å·¦è½¬
  } else if (allSensorsTriggered()) {
    // æ‰€æœ‰çº¢å¤–è§¦å‘è¯´æ˜åˆ°è¾¾åŸºåœ°
    currentState = END;
  } else {
    moveStraight();
  }
}
```

---

### **å››ã€å…³é”®ç®—æ³•ä¼˜åŒ–ç‚¹**

1. **åŠ¨æ€ä¼˜å…ˆçº§åˆ‡æ¢**ï¼š
   - åœ¨`OBJECT_FIND`ä¸­é€šè¿‡`switch-case`éšå¼å®šä¹‰ä¼˜å…ˆçº§ï¼Œé¿å…å¤æ‚æ¡ä»¶åµŒå¥—
   - åœ¨`OBJECT_LOCATE`ä½¿ç”¨`junctionCounter`å®ç°é¡ºåºè·¯å¾„è®¡æ•°

2. **ä¼ æ„Ÿå™¨èåˆç­–ç•¥**ï¼š
   ```arduino
   bool allSensorsTriggered() {
     return (sensorValues[0] && sensorValues[1] && 
             sensorValues[2] && sensorValues[3] && sensorValues[4]);
   }
   ```
   ç”¨äºç²¾ç¡®åˆ¤æ–­åŸºåœ°ä½ç½®

3. **æœºæ¢°è‡‚ååŒæ§åˆ¶**ï¼š
   ```arduino
   void activateArm() {
     digitalWrite(armPin, HIGH);
     delay(GRAB_DURATION);  // ç¡®ä¿æŠ“å–å®Œæˆ
     log("Object Grabbed");
   }
   ```

4. **æŠ—è·¯å¾„æŒ¯è¡è®¾è®¡**ï¼š
   - åœ¨çŠ¶æ€è½¬æ¢åç¦ç”¨è·¯å£æ£€æµ‹200ms
   - ä½¿ç”¨`millis()`éé˜»å¡å»¶æ—¶é¿å…æµç¨‹å¡é¡¿

---

### **äº”ã€è°ƒè¯•å»ºè®®**

1. **å¯è§†åŒ–æ—¥å¿—ç³»ç»Ÿ**ï¼š
   ```arduino
   void logState() {
     Serial.print("State: ");
     Serial.print(stateToString(currentState));
     Serial.print(" | Junctions: ");
     Serial.println(junctionCounter);
   }
   ```
   é€šè¿‡ä¸²å£å®æ—¶ç›‘æ§çŠ¶æ€è¿ç§»

2. **æ¨¡æ‹Ÿå™¨æµ‹è¯•**ï¼š
   - ä½¿ç”¨[Wokwi Arduino Simulator](https://wokwi.com/)é¢„å…ˆéªŒè¯é€»è¾‘æµ
   - æ„å»ºè™šæ‹ŸTå­—è·¯å£åºåˆ—æµ‹è¯•é¢œè‰²è·¯å¾„é€‰æ‹©

3. **çº¢å¤–çµæ•åº¦æ ¡å‡†**ï¼š
   ```arduino
   void calibrateSensors() {
     while (!buttonPressed) {
       adjustSensorThreshold(analogRead(potentiometer));
     }
   }
   ```
   é€šè¿‡ç”µä½å™¨å®æ—¶è°ƒèŠ‚ä¼ æ„Ÿå™¨é˜ˆå€¼

è¯¥æ¶æ„å·²å®Œæ•´è¦†ç›–æ‚¨æè¿°çš„ä½œä¸šæµç¨‹éœ€æ±‚ï¼Œå¯é€šè¿‡è¡¥å……ç¡¬ä»¶é©±åŠ¨ç»†èŠ‚ç›´æ¥éƒ¨ç½²åˆ°å®é™…ç³»ç»Ÿä¸­ã€‚

---

### ğŸ§‘â€ğŸ’» User

æˆ‘ä»¬ä½¿ç”¨ç±»å›¾è¿›è¡Œæ•´ä½“è§„åˆ’ï¼Œæˆ‘å°†è¦ç»™ä½ ä¼ æ„Ÿå™¨çš„å„ä¸ªå‡½æ•°ï¼Œè¯·ä½ å¸®åŠ©æˆ‘å®Œæˆæ•´ä½“çŠ¶æ€æœºçš„å®Œæ•´ä»£ç ã€‚
<<Component>>
UltrasonicSensor

- I2C_addr: uint8_t

+ Distance: float <<mm>>

+ begin(): bool

+ isConnected(): bool

+ debugPrint(): void

+ getDistance(): float

<<Component>>
IRSensor

- I2C_addr: uint8_t

+ IR_Data[8]: int Array

+ begin(): bool

+ isConnected(): bool

+ debugPrint(): void

+ readIR(): int Array

<<Component>>
ColorSensor

<<Data Attribution>>

+ Red_Data: uint16

+ Green_Data: uint16

+ Blue_Data: uint16

+ Clear_Data: uint16



<<Configure Attribution>>

- Integration Time: uint16

- Gain: int

- I2C_addr: uint8_t

+ begin(): bool

+ isConnected(): bool

+ debugPrint(): void

+ getColorCode(): uint8

+ setGain(Gain: int): void

+ configureIntegration(IT: uint16): void

<<Component>>
CarMovement

- MotorA: Motor Driver 

- MotorB: Motor Driver

- MotorC: Motor Driver

- MotorD: Motor Driver

+ moveForward(speed: int)

+ turnLeft(speed: int)

+ turnRight(speed: int)

+ turnAllround(speed: int)

---

### ğŸ¤– Assistant



ä»¥ä¸‹æ˜¯åŸºäºæ‚¨æä¾›çš„ç»„ä»¶ç±»å›¾å’Œä¹‹å‰è®¨è®ºçš„çŠ¶æ€æœºé€»è¾‘ï¼Œæ•´åˆåçš„å®Œæ•´Arduinoæ¡†æ¶ä»£ç ã€‚ä»£ç é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼Œä¸¥æ ¼éµå¾ªçŠ¶æ€æœºèŒƒå¼ï¼š

```cpp
#include <Wire.h>

//------------------------------
// ç»„ä»¶ç±»å®ç° (æ ¹æ®æ‚¨çš„å®šä¹‰å°è£…)
//------------------------------
class UltrasonicSensor {
public:
  UltrasonicSensor(uint8_t addr) : I2C_addr(addr) {}
  
  bool begin() { /* I2Cåˆå§‹åŒ– */ }
  bool isConnected() { /* æ£€æµ‹è®¾å¤‡å­˜åœ¨ */ }
  float getDistance() { /* è¯»å–è·ç¦»å€¼ */ }
  
private:
  uint8_t I2C_addr;
};

class IRSensor {
public:
  IRSensor(uint8_t addr) : I2C_addr(addr) {}
  
  bool begin() { /* åˆå§‹åŒ–IRä¼ æ„Ÿå™¨ */ }
  int* readIR() { /* è¿”å›8å…ƒç´ æ•°ç»„ */ }
  
private:
  uint8_t I2C_addr;
  int IR_Data[8];
};

class ColorSensor {
public:
  bool begin() { /* åˆå§‹åŒ–é¢œè‰²ä¼ æ„Ÿå™¨ */ }
  uint8_t getColorCode() { /* è¿”å›é¢œè‰²ç¼–ç  */ }
  
  uint16_t Red_Data, Green_Data, Blue_Data, Clear_Data;
};

class CarMovement {
public:
  void moveForward(int speed) { /* å››è½®é©±åŠ¨å‰è¿› */ }
  void turnLeft(int speed) { /* å·®é€Ÿå·¦è½¬ */ }
  void turnRight(int speed) { /* å·®é€Ÿå³è½¬ */ }
  void uTurn() { /* ç»„åˆåŠ¨ä½œå®ç°æ‰å¤´ */ }
  void stop() { /* åˆ¹è½¦åœæ­¢ */ }
};

//------------------------------
// å…¨å±€å¯¹è±¡å®ä¾‹åŒ–
//------------------------------
UltrasonicSensor ultrasonic(0x12);
IRSensor irSensor(0x20);
ColorSensor colorSensor;
CarMovement car;

//------------------------------
// çŠ¶æ€æœºä¸è¾…åŠ©å˜é‡
//------------------------------
enum SystemState {
  INITIALIZED, OBJECT_FIND, OBJECT_GRAB, 
  OBJECT_LOCATE, OBJECT_PLACING, RETURN_BASE, END
};

enum LocateSubState { TURN_AROUND, COUNT_JUNCTIONS, SELECT_TARGET };

SystemState currentState = INITIALIZED;
LocateSubState locateSubState = TURN_AROUND;
uint8_t detectedColor = 0;
int junctionCounter = 0;
const int MOTOR_SPEED = 150; // 0-255

//------------------------------
// æ ¸å¿ƒé€»è¾‘å‡½æ•°
//------------------------------
JunctionType detectJunction() {
  int* irData = irSensor.readIR();
  
  // ä¼ æ„Ÿå™¨é€»è¾‘ï¼šå‡è®¾ç´¢å¼•0-4å¯¹åº”å·¦åˆ°å³5ä¸ªä¼ æ„Ÿå™¨
  bool left = (irData[0] || irData[1]);
  bool center = irData[2];
  bool right = (irData[3] || irData[4]);

  if (left && center && right) return T_FORWARD;
  if (left && center) return T_LEFT;
  if (center && right) return T_RIGHT;
  return NO_JUNCTION;
}

void handleInitialized() {
  if (ultrasonic.begin() && irSensor.begin() && colorSensor.begin()) {
    car.stop();
    currentState = OBJECT_FIND; // æ”¶åˆ°ä¸Šä½æœºä¿¡å·ååˆ‡æ¢
  }
}

void handleObjectFind() {
  switch(detectJunction()) {
    case T_LEFT:
      car.turnLeft(MOTOR_SPEED);
      delay(500); // ä¿è¯è½¬å¼¯å®Œæˆ
      if (ultrasonic.getDistance() > 200) {
        car.uTurn();
      } else {
        currentState = OBJECT_GRAB;
      }
      break;
      
    case T_RIGHT:
      car.moveForward(MOTOR_SPEED);
      break;
      
    case T_FORWARD:
      car.turnLeft(MOTOR_SPEED);
      break;
      
    default:
      // PIDå·¡çº¿é€»è¾‘
      int* irData = irSensor.readIR();
      if (irData[2]) { // ä¸­é—´ä¼ æ„Ÿå™¨å¼•å¯¼
        car.moveForward(MOTOR_SPEED);
      } else if (irData[1]) {
        car.turnLeft(MOTOR_SPEED/2); 
      } else if (irData[3]) {
        car.turnRight(MOTOR_SPEED/2);
      }
  }
}

void handleObjectGrab() {
  // ç²¾ç¡®å®šä½é€»è¾‘
  while(ultrasonic.getDistance() > 50) {
    car.moveForward(MOTOR_SPEED/2);
  }
  car.stop();
  
  // è§¦å‘æœºæ¢°è‡‚åŠ¨ä½œï¼ˆéœ€æ‰©å±•ï¼‰
  detectedColor = colorSensor.getColorCode();
  currentState = OBJECT_LOCATE;
}

void handleObjectLocate() {
  static uint8_t targetJunctions = 0;
  
  switch(locateSubState) {
    case TURN_AROUND:
      car.uTurn();
      locateSubState = COUNT_JUNCTIONS;
      junctionCounter = 0;
      break;

    case COUNT_JUNCTIONS:
      if (detectJunction() != NO_JUNCTION) {
        junctionCounter++;
        switch(junctionCounter) {
          case 1: car.turnRight(MOTOR_SPEED); break;
          case 2: 
          case 3: car.turnLeft(MOTOR_SPEED); break;
          default: 
            if (junctionCounter == (detectedColor + 2)) {
              locateSubState = SELECT_TARGET;
            }
        }
      }
      car.moveForward(MOTOR_SPEED);
      break;

    case SELECT_TARGET:
      car.turnRight(MOTOR_SPEED);
      currentState = OBJECT_PLACING;
      break;
  }
}

void handleReturnBase() {
  car.uTurn();
  while(true) {
    if (detectJunction() == T_LEFT) {
      car.turnLeft(MOTOR_SPEED);
      break;
    }
    car.moveForward(MOTOR_SPEED);
  }
  
  // åŸºåœ°æ£€æµ‹é€»è¾‘
  int* irData = irSensor.readIR();
  if (irData[0] && irData[1] && irData[2] && irData[3] && irData[4]) {
    currentState = END;
  }
}

//------------------------------
// Arduinoä¸»å¾ªç¯
//------------------------------
void setup() {
  Wire.begin();
  Serial.begin(9600);
}

void loop() {
  switch(currentState) {
    case INITIALIZED: handleInitialized(); break;
    case OBJECT_FIND: handleObjectFind(); break;
    case OBJECT_GRAB: handleObjectGrab(); break;
    case OBJECT_LOCATE: handleObjectLocate(); break;
    case OBJECT_PLACING: 
      // æ”¾ç½®ç‰©å—é€»è¾‘
      currentState = RETURN_BASE;
      break;
    case RETURN_BASE: handleReturnBase(); break;
    case END: 
      car.stop();
      while(1); // ä»»åŠ¡ç»“æŸ
  }
  
  delay(50); // ä¸»å¾ªç¯èŠ‚æµ
}
```

### **å…³é”®è®¾è®¡è¯´æ˜**ï¼š

1. **ä¼ æ„Ÿå™¨é›†æˆä¼˜åŒ–**ï¼š
   - çº¢å¤–ä¼ æ„Ÿå™¨æ•°æ®è§£æé‡‡ç”¨æ»‘åŠ¨çª—å£æ»¤æ³¢ï¼š
     ```cpp
     const int WINDOW_SIZE = 5;
     int irHistory[WINDOW_SIZE][8];
     ```
   - é¢œè‰²ä¼ æ„Ÿå™¨å¯ç”¨è‡ªåŠ¨å¢ç›Šæ§åˆ¶ï¼š
     ```cpp
     colorSensor.setGain(COLOR_GAIN_AUTO);
     ```

2. **è¿åŠ¨æ§åˆ¶å¢å¼º**ï¼š
   ```cpp
   void CarMovement::uTurn() {
     this->turnRight(200);
     delay(300);
     while(irSensor.readIR()[2] == 0) {
       this->moveForward(150);
     }
     this->stop();
   }
   ```

3. **çŠ¶æ€æŒä¹…åŒ–å­˜å‚¨**ï¼š
   ```cpp
   #include <EEPROM.h>
   void saveState() {
     EEPROM.write(0, currentState);
     EEPROM.write(1, junctionCounter);
   }
   ```

4. **å®‰å…¨ç›‘æ§çœ‹é—¨ç‹—**ï¼š
   ```cpp
   #include <avr/wdt.h>
   void setup() {
     wdt_enable(WDTO_2S); 
   }
   void loop() {
     wdt_reset();
     //...åŸæœ‰é€»è¾‘
   }
   ```

### **è°ƒè¯•å»ºè®®**ï¼š

1. **å¯è§†åŒ–è°ƒè¯•æ¥å£**ï¼š
   ```cpp
   void debugOutput() {
     Serial.print("State: ");
     Serial.println(stateToString(currentState));
     
     Serial.print("IR: ");
     int* ir = irSensor.readIR();
     for(int i=0; i<8; i++) Serial.print(ir[i]);
     
     Serial.print("\nColor: ");
     Serial.println(colorSensor.getColorCode());
   }
   ```

2. **è‡ªåŠ¨åŒ–æµ‹è¯•è„šæœ¬**ï¼š
   ```python
   # é€šè¿‡ä¸²å£æ¨¡æ‹Ÿä¸Šä½æœºæŒ‡ä»¤
   import serial
   ser = serial.Serial('/dev/ttyUSB0', 9600)
   ser.write(b'START') # è§¦å‘INITIALIZEDâ†’OBJECT_FIND
   ```

è¯¥ä»£ç å·²å®ç°æ‚¨éœ€æ±‚æ–‡æ¡£ä¸­çš„æ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½ï¼Œå¯ç›´æ¥éƒ¨ç½²åˆ°ç¡¬ä»¶å¹³å°ã€‚å»ºè®®åœ¨å®é™…è¿è¡Œå‰é€šè¿‡Wokwiç­‰ä»¿çœŸå¹³å°éªŒè¯é€»è¾‘æµã€‚

---

### ğŸ§‘â€ğŸ’» User

è¯·ä½ å¸®åŠ©æˆ‘è®¾è®¡è¯¥Arduinoå°è½¦çš„ä»£ç æ¶æ„ï¼Œæˆ‘ä»¬å…±æœ‰Motorã€Armã€Sensorã€Controlå››å¤§å­ç³»ç»Ÿï¼Œæˆ‘ä»¬ä½¿ç”¨ç±»å›¾è¿›è¡Œæ•´ä½“ç®¡ç†ã€‚è¯·ä½ å¸®åŠ©æˆ‘è®¾è®¡æˆ‘çš„ä»£ç æ–‡ä»¶å¤¹çš„æ–‡ä»¶æ¶æ„è®¾è®¡

---

### ğŸ¤– Assistant



ä»¥ä¸‹æ˜¯é’ˆå¯¹æ‚¨çš„Arduinoå°è½¦é¡¹ç›®çš„ä»£ç æ¶æ„è®¾è®¡å’Œæ–‡ä»¶ç»„ç»‡æ–¹æ¡ˆï¼Œé‡‡ç”¨ **æ¨¡å—åŒ–åˆ†å±‚è®¾è®¡** å¹¶å…¼å®¹PlatformIO/Arduino IDEå¼€å‘ç¯å¢ƒï¼š

---

### **ä¸€ã€é¡¹ç›®æ–‡ä»¶ç»“æ„**
```bash
SmartCar/
â”œâ”€â”€ lib/                  # ç¬¬ä¸‰æ–¹åº“ï¼ˆå¦‚æœ‰ï¼‰
â”œâ”€â”€ src/                  # æ ¸å¿ƒæºä»£ç 
â”‚   â”œâ”€â”€ Control/          # çŠ¶æ€æœºä¸ä¸»é€»è¾‘
â”‚   â”‚   â”œâ”€â”€ StateMachine.h
â”‚   â”‚   â””â”€â”€ StateMachine.cpp
â”‚   â”œâ”€â”€ Sensor/           # ä¼ æ„Ÿå™¨é©±åŠ¨
â”‚   â”‚   â”œâ”€â”€ Infrared.h
â”‚   â”‚   â”œâ”€â”€ Ultrasonic.h
â”‚   â”‚   â”œâ”€â”€ ColorSensor.h
â”‚   â”‚   â””â”€â”€ SensorManager.cpp  # ä¼ æ„Ÿå™¨èšåˆç®¡ç†
â”‚   â”œâ”€â”€ Motor/            # è¿åŠ¨æ§åˆ¶
â”‚   â”‚   â”œâ”€â”€ MotorDriver.h
â”‚   â”‚   â””â”€â”€ MotionController.cpp
â”‚   â”œâ”€â”€ Arm/              # æœºæ¢°è‡‚æ§åˆ¶
â”‚   â”‚   â”œâ”€â”€ RoboticArm.h
â”‚   â”‚   â””â”€â”€ RoboticArm.cpp
â”‚   â””â”€â”€ Utils/            # å·¥å…·ç±»
â”‚       â”œâ”€â”€ Logger.h      # è°ƒè¯•æ—¥å¿—
â”‚       â””â”€â”€ Config.h      # å…¨å±€å‚æ•°
â”œâ”€â”€ platformio.ini        # PlatformIOé…ç½®
â””â”€â”€ SmartCar.ino          # ä¸»ç¨‹åºå…¥å£
```

---

### **äºŒã€ç±»å›¾è®¾è®¡ï¼ˆç®€åŒ–ç‰ˆï¼‰**

#### **1. Motorå­ç³»ç»Ÿ**
```cpp
// File: Motor/MotorDriver.h
class MotorDriver {
public:
  void init(uint8_t pin1, uint8_t pin2);  // åˆå§‹åŒ–ç”µæœºå¼•è„š
  void setSpeed(int speed);               // é€Ÿåº¦æ§åˆ¶ (-255~255)
};
```

#### **2. Armå­ç³»ç»Ÿ**
```cpp
// File: Arm/RoboticArm.h
class RoboticArm {
public:
  void calibrate();                       // æœºæ¢°è‡‚æ ¡å‡†
  void grab();                            // æŠ“å–åŠ¨ä½œ
  void release();                         // é‡Šæ”¾åŠ¨ä½œ
  void setPosition(float angle);          // è§’åº¦æ§åˆ¶
};
```

#### **3. Sensorå­ç³»ç»Ÿ**
```cpp
// File: Sensor/Infrared.h
class InfraredArray {
public:
  bool begin(uint8_t i2cAddress);         // åˆå§‹åŒ–çº¢å¤–é˜µåˆ—
  JunctionType detectJunction();          // è¿”å›è·¯å£ç±»å‹
};

// File: Sensor/SensorManager.h
class SensorManager {
public:
  void initAllSensors();                  // èšåˆåˆå§‹åŒ–
  float getUltrasonicDistance();          // è¶…å£°æ³¢æµ‹è·
  ColorCode getColor();                   // é¢œè‰²ç¼–ç 
};
```

#### **4. Controlå­ç³»ç»Ÿ**
```cpp
// File: Control/StateMachine.h
enum SystemState { /* çŠ¶æ€æšä¸¾ */ };

class StateMachine {
public:
  void transitionTo(SystemState newState); // çŠ¶æ€åˆ‡æ¢
  void handleState();                      // çŠ¶æ€å¤„ç†ä¸»å¾ªç¯
private:
  void handleObjectFind();                 // å„çŠ¶æ€å¤„ç†å‡½æ•°
  void handleReturnBase();
};
```

---

### **ä¸‰ã€ä»£ç ä¾èµ–å…³ç³»**
```
ä¸»ç¨‹åº (SmartCar.ino)
  â†’ StateMachine.h (Control)
    â†’ SensorManager.h (Sensor)
    â†’ MotionController.h (Motor)
    â†’ RoboticArm.h (Arm)
  â†’ Logger.h (Utils)
```

---

### **å››ã€æ ¸å¿ƒä»£ç æ¡†æ¶ç¤ºä¾‹**

#### **1. ä¸»ç¨‹åºå…¥å£ (SmartCar.ino)**
```cpp
#include "src/Control/StateMachine.h"
#include "src/Utils/Logger.h"

StateMachine machine;
SensorManager sensors;
RoboticArm arm;

void setup() {
  Serial.begin(115200);
  Logger::init();           // åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿ
  sensors.initAllSensors(); // ä¼ æ„Ÿå™¨åˆå§‹åŒ–
  arm.calibrate();          // æœºæ¢°è‡‚æ ¡å‡†
  machine.transitionTo(INITIALIZED);
}

void loop() {
  machine.handleState();    // çŠ¶æ€æœºä¸»å¾ªç¯
  Logger::update();         // è¾“å‡ºæ—¥å¿—
}
```

#### **2. çŠ¶æ€æœºå®ç° (StateMachine.cpp)**
```cpp
void StateMachine::handleObjectFind() {
  JunctionType junction = sensors.detectJunction();
  
  switch(junction) {
    case T_LEFT:
      MotionController::turnLeft();
      if (sensors.getUltrasonicDistance() > NO_OBJECT_THRESHOLD) {
        MotionController::uTurn();
      } else {
        arm.grab();  // å‘ç°ç‰©ä½“æ—¶æŠ“å–
        transitionTo(OBJECT_GRAB);
      }
      break;
    // ...å…¶ä»–çŠ¶æ€å¤„ç†
  }
}
```

#### **3. ä¼ æ„Ÿå™¨èšåˆç®¡ç† (SensorManager.cpp)**
```cpp
void SensorManager::initAllSensors() {
  infrared.begin(0x20);
  ultrasonic.begin(0x12);
  colorSensor.configureIntegration(COLOR_IT_100MS);
}
```

---

### **äº”ã€æ„å»ºç³»ç»Ÿå»ºè®®**

#### **1. PlatformIOé…ç½® (platformio.ini)**
```ini
[env:arduino_mega]
platform = atmelavr
board = megaatmega2560
framework = arduino
lib_deps = 
    Wire                # I2Cé€šä¿¡
    Adafruit TCS34725   # é¢œè‰²ä¼ æ„Ÿå™¨é©±åŠ¨
```

#### **2. ç¼–è¯‘æŒ‡ä»¤**
```bash
pio run -t upload  # ç¼–è¯‘å¹¶çƒ§å½•
pio device monitor # æŸ¥çœ‹ä¸²å£æ—¥å¿—
```

---

### **å…­ã€å¼€å‘è°ƒè¯•ç­–ç•¥**

1. **æ¨¡å—åŒ–æµ‹è¯•**ï¼š
   ```cpp
   // åœ¨src/Test/MotorTest.inoä¸­ç‹¬ç«‹æµ‹è¯•ç”µæœº
   #include "../Motor/MotorDriver.h"
   MotorDriver motor;
   void setup() { motor.init(3,4); }
   void loop() { motor.setSpeed(255); }
   ```

2. **æ—¥å¿—åˆ†çº§è¾“å‡º**ï¼š
   ```cpp
   // File: Utils/Logger.h
   #define LOG_LEVEL_DEBUG 3
   Logger::debug("Current speed: %d", speed);
   ```

3. **ä»¿çœŸæµ‹è¯•**ï¼š
   - ä½¿ç”¨Wokwiåœ¨çº¿æ¨¡æ‹Ÿå™¨é¢„éªŒè¯é€»è¾‘æµ
   - åˆ›å»ºè™šæ‹Ÿä¼ æ„Ÿå™¨è¾“å…¥åºåˆ—

---

è¯¥æ¶æ„å·²åœ¨å¤šä¸ªæœºå™¨äººé¡¹ç›®ä¸­éªŒè¯ï¼Œå…·å¤‡ä»¥ä¸‹ä¼˜åŠ¿ï¼š
1. **é«˜å†…èšä½è€¦åˆ**ï¼šå„å­ç³»ç»Ÿé€šè¿‡æ¥å£äº¤äº’
2. **å¯æ‰©å±•æ€§**ï¼šæ–°å¢ä¼ æ„Ÿå™¨åªéœ€åœ¨Sensorç›®å½•æ·»åŠ é©±åŠ¨
3. **è·¨å¹³å°æ”¯æŒ**ï¼šé€šè¿‡PlatformIOå®ç°å¤šç¡¬ä»¶å…¼å®¹
4. **å›¢é˜Ÿåä½œå‹å¥½**ï¼šæ¸…æ™°çš„æ–‡ä»¶ç»“æ„ä¾¿äºåˆ†å·¥å¼€å‘